// --- 4.1 Объекты ---
// Напишите код, выполнив задание из каждого пункта отдельной строкой:
/*1. Создайте пустой объект user.
  2. Добавьте свойство name со значением John.
  3. Добавьте свойство surname со значением Smith.
  4. Измените значение свойства name на Pete.
  5. Удалите свойство name из объекта.*/
let user = {};
user.name = "John";
user.surname = "Smith";
user.name = "Pete";
delete user.name;
// --------------------------------------------------------------------------------------------------
//   Напишите функцию isEmpty(obj), которая возвращает true, если у объекта нет свойств, иначе false
function isEmpty(obj) {
    for (let key in obj) {
        return false;
    }
    return true;
}
// --------------------------------------------------------------------------------------------------
// Можно ли изменить объект, объявленный с помощью const? Как вы думаете?
const user = {
    name: "John"
};

// это будет работать?
user.name = "Pete"; // это будет работать, т.к. тут происходит изменение содержимого объекта

/* Ответ: const защищает от изменений только саму переменную, а не её содержимое.
          Ошибка будет, если попытаться присваить переменной новое значение, например, user = *что-то*  */
// --------------------------------------------------------------------------------------------------
/* Напишите код для суммирования всех зарплат и сохраните результат в переменной sum. Должно получиться 390.
Если объект salaries пуст, то результат должен быть 0.*/
let salaries = {
    John: 100,
    Ann: 160,
    Pete: 130
}

let sumSalaries = 0;
for (key in salaries) {
    sumSalaries += salaries[key];
}
alert(sumSalaries);


// --- 4.4 Методы объекта, "this" ---
// Здесь функция makeUser возвращает объект.
// Каким будет результат при обращении к свойству объекта ref? Почему?
function makeUser() {
    return {
        name: "Джон",
        ref: this
    };
};

let user = makeUser();

alert(user.ref.name); // Каким будет результат?

/* Ответ: будет ошибка, т.к. значение this внутри makeUser() является undefined (это связано с тем,
          что makeUser() вызывается как функция, а не как метод)*/
// --------------------------------------------------------------------------------------------------
// Создайте калькулятор
/* Создайте объект calculator (калькулятор) с тремя методами:

read() (читать) запрашивает два значения и сохраняет их как свойства объекта.
sum() (суммировать) возвращает сумму сохранённых значений.
mul() (умножить) перемножает сохранённые значения и возвращает результат. */
let calculator = {
    read() {
        this.numA = +prompt("Введите первое число", "");
        this.numB = +prompt("Введите второе число", "");
    },

    sum() { return this.numA + this.numB; },

    mul() { return this.numA * this.numB; }
};

calculator.read();
alert(calculator.sum());
alert(calculator.mul());

// --- 4.5 Конструкторы, создание объектов через "new" ---
// Создание калькулятора при помощи конструктора
/* Создайте функцию-конструктор Calculator, который создаёт объекты с тремя методами:

read() запрашивает два значения при помощи prompt и сохраняет их значение в свойствах объекта.
sum() возвращает сумму введённых свойств.
mul() возвращает произведение введённых свойств.*/
function calConstractor() {
    this.read = function () {
        this.numA = +prompt("Введите первое число", "");
        this.numB = +prompt("Введите второе число", "");
    };

    this.sum = function () { return this.numA + this.numB; };

    this.mul = function () { return this.numA * this.numB; };
}

let calculatorConstr = new calConstractor();
calculatorConstr.read();

alert("Sum = " + calculatorConstr.sum());
alert("Mul = " + calculatorConstr.mul());
// --------------------------------------------------------------------------------------------------
// Создаём Accumulator
/*Напишите функцию-конструктор Accumulator(startingValue).
Объект, который она создаёт, должен уметь следующее:

Хранить «текущее значение» в свойстве value. 
Начальное значение устанавливается в аргументе конструктора startingValue.
Метод read() использует prompt для получения числа и прибавляет его к свойству value.
Таким образом, свойство value является текущей суммой всего, что ввёл пользователь при вызовах метода read(),
с учётом начального значения startingValue.*/

function Accumulator(startingValue) {
    this.value = startingValue;

    this.read = function() {
        this.value += +prompt("Введите число, которое хотите добавить", "");
    }

}

let accumulator = new Accumulator(1); // начальное значение 1

accumulator.read(); 
accumulator.read();

alert(accumulator.value);